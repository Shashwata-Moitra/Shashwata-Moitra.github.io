## Example -1: Hello World

```c++

// This is executed using intel SYCL compiler.
// With other compiler execution style might be different.


#include <CL/sycl.hpp> //importing sycl, different for hipSYCL
#include <iostream>
using namespace sycl; // Needs to be cautious when using hipSYCL. 
//With hip SYCL we need to use sycl:: at every line.

const std::string secret {
    "Ifmmp-!xpsme\"\012J(n!tpssz-!Ebwf/!"
    "J(n!bgsbje!J!dbo(u!ep!uibu/!.!IBM\01"};
const auto sz = secret.size();

int main(){
    queue Q; //Creates a queue for new job request.
    char*result = malloc_shared<char>(sz, Q); //Allocation for the data to be shared with GPU
    std::memcpy(result,secret.data(),sz); //Copies the data to the GPU.
    // Q.memcpy(result,secret.data(),sz).wait(); //SYCL queue alternative

    // Code below runs on GPU in parallel.
    Q.parallel_for(sz,[=](auto&i) {  //parallel_for distribute the work into gpu cores async
        result[i] -= 1;
    }).wait(); // To wait for async parallel_for all the task to finish.

    std::cout << result << "\n";
    return 0;
}

```

##### The above code will produce the following result:

Hello, world!	I'm sorry, Dave. I'm afraid I can't do that. - HAL

##### Reference parallel_for CPU form:

```c++

// Fortran loop
do i = 1, n
    z(i) = alpha * x(i) + y(i)
end do


// C++ loop
for (int i=0;i<n;i++) {
    z[i] = alpha * x[i] + y[i];
}


// SYCL kernel
myq.parallel_for(range{n},[=](id<1> i) {
    z[i] = alpha * x[i] + y[i];
}).wait();

```

## Example -2: Vector Addition in GPU

```c++

#include <iostream>
#include <CL/sycl.hpp>

using namespace sycl;
class vector_addition;

int main(int, char**) {

   float4 vec_a = { 2.0, 3.0, 7.0, 4.0 };
   float4 vec_b = { 4.0, 6.0, 1.0, 3.0 };
   float4 vec_c = { 0.0, 0.0, 0.0, 0.0 };

   default_selector device_selector;

   queue queue(device_selector);

   std::cout << "Running on "
             << queue.get_device().get_info<info::device::name>()
             << "\n";
   {
      buffer<float4, 1> vec_a_sycl(&vec_a, range<1>(1));
      buffer<float4, 1> vec_b_sycl(&vec_b, range<1>(1));
      buffer<float4, 1> vec_c_sycl(&vec_c, range<1>(1));

      queue.submit([&] (cl::sycl::handler& cgh) {

         auto vec_a_acc = vec_a_sycl.get_access<access::mode::read>(cgh);
         auto vec_b_acc = vec_b_sycl.get_access<access::mode::read>(cgh);
         auto vec_c_acc = vec_c_sycl.get_access<access::mode::discard_write>(cgh);

         cgh.single_task<class vector_addition>([=] () {
         vec_c_acc[0] = vec_a_acc[0] + vec_b_acc[0];
         });
      });
   }

   std::cout << "  Vec_A { " << vec_a.x() << ", " << vec_a.y() << ", " << vec_a.z() << ", " << vec_a.w() << " }\n"
        << "+ Vec_B { " << vec_b.x() << ", " << vec_b.y() << ", " << vec_b.z() << ", " << vec_b.w() << " }\n"
        << "----------------------\n"
        << "= Vec_C { " << vec_c.x() << ", " << vec_c.y() << ", " << vec_c.z() << ", " << vec_c.w() << " }"
        << std::endl;

   return 0;
}

```